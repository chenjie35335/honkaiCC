上次设计的数据结构的耦合性太强，这次重新设计

对于RawValue和Memory来说，基本上可以确定为11对应关系
但是对于register和RawValue来说，不一定
随着遍历的进行会进行存入和读取

由于某个时刻Value和Register是对应的，所以
初始时刻寄存器未满时，来一个分配一个，当寄存器已满时，根据使用的频率换出

使用的频率应该还是使用hash表，只是访问一次变化一次

综上，对于register部分需要做到
两个unordered_map

1个用来存<寄存器,原始值>，不断修改原始值内容
1个用来存<原始值，使用次数> ，不断修改次数

这个交给backend中的StackManager 和 RegisterManager就行

一个C语言的语法常识：
尽量不要使用 const *

这里使用了双层的const *
第一层表示这个指针不能修改原先的内存的值，只能读取
第二层表示这个指针函数调用之后不能修改
这时取&就不会报错了

对于这个const的问题，文档这里做出以下解释：
对于使用变量赋值常量这种事情，我的想法就是说要

0 a
4 sum
8 b
12 a
16 b

现在比较难办的事情是如何切换的问题，现在给出方案
1、 我们知道在FuncDef时建立一个RawFunction没毛病，但是何时建立
RawBasicBlock是个问题，如果对应到AST,如果放到multiBlock那里当前访问的BasicBlock,可能会有更好的效果，根据访问到的语句，调整语句块的;但是如何开始调整语句块呢？
（1）首先在if-then-else那个位置，br指令之后，设定当前所在的basicblock结束
（2）现在对于替换RawBasicBlock的算法有以下问题
如果是返回multiBlock再判断就会存在一个问题在于跳跃的问题
这个就涉及到我的结构的问题，RawSlice这个是大问题，无法直接访问上层的RawBasicBlock,导致这里我们没有办法直接标记RawBasicBlock结束，可能还需要表（虽然上述方法还是需要表）

对此定义如下：
1、 在multiBlockItem的循环那里判断是否需要更换RawBasicBlock
2、 需要一个变量标志当前RawBasicBlock是否结束
3、 需要一个变量表示当前活跃的RawBasicBlock！
有了当前的活跃变量之后我们发现：generateGraph无需使用IR传参了，当要调取的时候调用这个全局变量即可

现在解决的问题是函数的定义和参数的问题，主要有以下的难点：
1、 目前来看，参数存储在params当中，这些参数应该需要提前分配寄存器和栈空间，同时这些参数应该和后面insts中的节点相连才能发挥作用
2、 参数的类型应该在后端分配时候就确定了
3、 对于中端来说，参数应该说在params当中，然后直接使用params来连接insts，无需过于麻烦
4、 对于函数调用来说，先通过函数表查找到对应函数的RawFunction,再通过ty来判断参数调用是否合法，不合法就报错，合法就连接
5、 从前端开始ast关于参数的问题：
为了做一个简单的简化，做以下更改
（1） 我们对于函数参数不重新进行存储，对于函数参数
可以直接使用
（2） 其实我们发现，对于后端来说，一个名字对应了一个变量***
一定程度上，这个可能会帮我们重新设计这个符号表

现在有一个问题：
1、 中端有两个数据结构，一个是符号表，一个是irbuilder,
一个用于记录历史，一个记录当前，应该都是有必要的！
严格记住：符号表和irbuilder只能在中端ast转cfg时候起作用，理论上来说ast应该也是，但是智能指针已经保证了所以当结束时候都应该释放

现在主要解决返回值问题，做以下的分类讨论：
1、 如果是有返回值，但是代码中（函数的最后一个bb）无返回值时，直接ret就行（到时候a0中存什么就是什么）
2、 如果是无返回值，但是代码中存在返回值，需要报错（这时只需要看tempFunction是否有返回值就行）
3、 如果是有返回值，且函数最后一个bb有返回值，没有任何问题，funcdef那里也无需其他处理
4、 如果无返回值，且函数到最后一个bb都没有返回值，没有任何问题，但是funcdef那里需要一个ret值  
5、 如何判断返回值是一个问题，关键问题在于这个东西应该存在哪里，是直接存在后端的节点当中吗
还是说我们要重新建立一个散列表专门来表示？
（考虑到如果函数调用时要使用返回值，还是必须一个表来存储，毕竟如果使用遍历复杂度有点高）
 (这个散列表貌似还得建立从string到RawFunction之间的关系散列表，就需要在RawFunction当中存储返回值信息)

对于常数来说，这里做出一些妥协：
1、 还是转换成字符串和MidVar存在一起

加入函数之后，就会存在一些问题：
1、 首先是寄存器和栈空间管理的问题
对于栈空间来说，每当访问一个函数时，都要求重新分配栈空间，相当于说，一个函数结束后，栈空间分配器需要
复位，无需管理其他任何问题，我只要考虑，只要根据值分配，然后访问时做一个映射即可

但是寄存器就较为恶心了，这里做出以下的设计
1、首先原先的策略不变
2、对于特定寄存器，特定函数直接分配，不参与其他过程的寄存器分配
3、还是用的保存，不用的不管，但是这个可能得遍历一遍寄存器表
调用前检查一边，存入，调用后的方式是：貌似还是得特定一个模块来专门管理这部分内容
也就是说还是需要再分配一块内存来弄
重新设计后端的这个硬件
做出以下设计：
1、每一个函数需要一个寄存器分配器，
2、每一个函数需要一个栈分配器，
存储保留的寄存器从高往低分配